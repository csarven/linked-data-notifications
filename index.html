<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8" />
        <title>Linked Data Notifications</title>
        <meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="https://dokie.li/media/css/basic.css" media="all" rel="stylesheet alternate" title="Basic" />
        <link href="https://dokie.li/media/css/lncs.css" media="all" rel="stylesheet" title="LNCS" />
        <link href="https://dokie.li/media/css/acm.css" media="all" rel="stylesheet alternate" title="ACM" />
        <link href="https://www.w3.org/StyleSheets/TR/2016/W3C-UD" media="all" rel="stylesheet alternate" title="W3C-UD" />
        <link href="https://dokie.li/media/css/do.css" media="all" rel="stylesheet" />
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" media="all" rel="stylesheet" />
        <link href="https://dokie.li/media/css/editor.css" media="all" rel="stylesheet" />
        <script src="https://dokie.li/scripts/simplerdf.js"></script>
        <script src="https://dokie.li/scripts/medium-editor.min.js"></script>
        <script src="https://dokie.li/scripts/medium-editor-tables.min.js"></script>
        <script src="https://dokie.li/scripts/do.js"></script>
    </head>

    <body about="" prefix="rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# rdfs: http://www.w3.org/2000/01/rdf-schema# owl: http://www.w3.org/2002/07/owl# xsd: http://www.w3.org/2001/XMLSchema# dcterms: http://purl.org/dc/terms/ dctypes: http://purl.org/dc/dcmitype/ foaf: http://xmlns.com/foaf/0.1/ v: http://www.w3.org/2006/vcard/ns# pimspace: http://www.w3.org/ns/pim/space# cc: http://creativecommons.org/ns# skos: http://www.w3.org/2004/02/skos/core# prov: http://www.w3.org/ns/prov# qb: http://purl.org/linked-data/cube# schema: http://schema.org/ rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# cal: http://www.w3.org/2002/12/cal/ical# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# org: http://www.w3.org/ns/org# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ sioc: http://rdfs.org/sioc/ns# doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ oa: http://www.w3.org/ns/oa# as: http://www.w3.org/ns/activitystreams# ldp: http://www.w3.org/ns/ldp# solid: http://www.w3.org/ns/solid/terms#" typeof="schema:CreativeWork sioc:Post prov:Entity">
        <main>
            <article about="" typeof="schema:Article">
                <h1 property="schema:name">Linked Data Notifications</h1>

                <div id="authors">
                    <dl id="author-name">
                        <dt>Authors</dt>
                        <dd id="Sarven-Capadisli" inlist="" rel="bibo:authorList" resource="http://csarven.ca/#i"><span about="" rel="schema:contributor schema:creator schema:publisher schema:author"><span about="http://csarven.ca/#i" typeof="schema:Person"><a href="http://csarven.ca/" rel="schema:url"><span about="http://csarven.ca/#i" property="schema:name"><span property="schema:givenName">Sarven</span> <span property="schema:familyName">Capadisli</span></span></a></span></span><sup><a about="http://csarven.ca/#i" href="#author-org-1" rel="schema:memberOf" resource="http://dbpedia.org/resource/University_of_Bonn">1</a></sup><sup><a href="#author-email-1">‚úä</a></sup></dd>
                        <dd id="Amy-Guy" inlist="" rel="bibo:authorList" resource="http://rhiaro.co.uk/about#me"><span about="" rel="schema:creator schema:author"><span about="http://rhiaro.co.uk/#me" typeof="schema:Person"><a href="http://rhiaro.co.uk/" rel="schema:url"><span about="http://rhiaro.co.uk/#me" property="schema:name"><span property="schema:givenName">Amy</span> <span property="schema:familyName">Guy</span></span></a></span></span><sup><a about="http://rhiaro.co.uk/about#me" href="#author-org-2" rel="schema:memberOf" resource="http://dbpedia.org/resource/University_of_Edinburgh">2</a></sup><sup><a href="#author-email-2">üê¶</a></sup></dd>
                        <dd id="Christoph-Lange" inlist="" rel="bibo:authorList" resource="http://eis.iai.uni-bonn.de/ChristophLange"><span about="" rel="schema:contributor"><a about="http://eis.iai.uni-bonn.de/ChristophLange" href="https://langec.wordpress.com/about/" property="schema:name" rel="schema:url" typeof="schema:Person">Christoph Lange</a></span><sup><a about="http://eis.iai.uni-bonn.de/ChristophLange" href="#author-org-1" rel="schema:memberOf" resource="http://dbpedia.org/resource/University_of_Bonn">1</a></sup><sup><a href="#author-email-3">‚à´</a></sup></dd>
                        <dd id="S√∂ren-Auer" inlist="" rel="bibo:authorList" resource="http://eis.iai.uni-bonn.de/SoerenAuer"><span about="" rel="schema:contributor"><a about="http://eis.iai.uni-bonn.de/SoerenAuer" href="http://eis.iai.uni-bonn.de/SoerenAuer.html" property="schema:name" rel="schema:url" typeof="schema:Person">S√∂ren Auer</a></span><sup><a about="http://eis.iai.uni-bonn.de/SoerenAuer" href="#author-org-1" rel="schema:memberOf" resource="http://dbpedia.org/resource/University_of_Bonn">1</a></sup><sup><a href="#author-email-4">‚öõ</a></sup></dd>
                        <dd id="Tim-Berners-Lee" inlist="" rel="bibo:authorList" resource="https://www.w3.org/People/Berners-Lee/card#i"><span about="" rel="schema:contributor"><a about="https://www.w3.org/People/Berners-Lee/card#i" href="https://www.w3.org/People/Berners-Lee/" property="schema:name" rel="schema:url" typeof="schema:Person">Tim Berners-Lee</a></span><sup><a about="https://www.w3.org/People/Berners-Lee/card#i" href="#author-org-4" rel="schema:memberOf" resource="http://dbpedia.org/resource/Massachusetts_Institute_of_Technology">3</a></sup><sup><a href="#author-email-5">üï∏</a></sup></dd>
                    </dl>

                    <ul id="author-org">
                        <li id="author-org-1"><sup>1</sup>Enterprise Information Systems Department, <a about="http://dbpedia.org/resource/University_of_Bonn" href="http://uni-bonn.de/" property="schema:name" rel="schema:url" typeof="schema:Organization">University of Bonn</a>, Bonn, Germany</li>
                        <li id="author-org-2"><sup>2</sup>School of Informatics, <a about="http://dbpedia.org/resource/University_of_Edinburgh" href="http://inf.ed.ac.uk/" property="schema:name" rel="schema:url" typeof="schema:Organization">University of Edinburgh</a>, Edinburgh, UK</li>
                        <li id="author-org-3"><sup>3</sup>Decentralized Information Group, CSAIL, <a about="http://dbpedia.org/resource/Massachusetts_Institute_of_Technology" href="https://mit.edu/" property="schema:name" rel="schema:url" typeof="schema:Organization">MIT</a>, Cambridge, US</li>
                    </ul>

                    <ul id="author-email">
                        <li id="author-email-1"><sup>‚úä</sup><a about="http://csarven.ca/#i" href="mailto:info@csarven.ca" rel="schema:email">info@csarven.ca</a></li>
                        <li id="author-email-2"><sup>üê¶</sup><a about="http://rhiaro.co.uk/about#me" href="mailto:amy@rhiaro.co.uk" rel="schema:email">amy@rhiaro.co.uk</a></li>
                        <li id="author-email-3"><sup>‚à´</sup><a about="http://eis.iai.uni-bonn.de/ChristophLange" href="mailto:langec@cs.uni-bonn.de" rel="schema:email">langec@cs.uni-bonn.de</a></li>
                        <li id="author-email-4"><sup>‚öõ</sup><a about="http://eis.iai.uni-bonn.de/SoerenAuer" href="mailto:auer@cs.uni-bonn.de" rel="schema:email">auer@cs.uni-bonn.de</a></li>
                        <li id="author-email-5"><sup>üï∏</sup><a about="https://www.w3.org/People/Berners-Lee/card#i" href="mailto:timbl@w3.org" rel="schema:email">timbl@w3.org</a></li>
                    </ul>
                </div>

                <dl id="document-identifier">
                    <dt>Identifier</dt>
                    <dd><a href="http://csarven.ca/linked-data-notifications" rel="owl:sameAs">http://csarven.ca/linked-data-notifications</a></dd>
                </dl>

                <dl id="document-in-reply-to">
                    <dt>In Reply To</dt>
                    <dd><a href="http://2017.eswc-conferences.org/call-papers" rel="sioc:reply_of">ESWC 2017 Call for Papers</a></dd>
                </dl>

                <dl id="document-published">
                    <dt>Published</dt>
                    <dd><time datatype="xsd:dateTime" datetime="2016-05-01T00:00:00Z" property="schema:datePublished">2016-05-01</time></dd>
                </dl>

                <dl id="document-modified">
                    <dt>Modified</dt>
                    <dd><time datatype="xsd:dateTime" datetime="2016-12-09T00:00:00Z" property="schema:dateModified">2016-12-09</time></dd>
                </dl>

                <dl id="document-license">
                    <dt>License</dt>
                    <dd><a href="https://creativecommons.org/licenses/by/4.0/" rel="schema:license" title="Creative Commons Attribution 4.0 Unported">CC BY 4.0</a></dd>
                </dl>

                <div id="content">
                    <section id="abstract">
                        <h2>Abstract</h2>
                        <div datatype="rdf:HTML" property="schema:abstract">
                          <p>In this article we describe the Linked Data Notifications (LDN) protocol, which is a Candidate Recommendation of the W3C (<a href="https://www.w3.org/TR/ldn/">https://www.w3.org/TR/ldn/</a>).
                          Notifications are sent over the Web for a variety of purposes, for example, by social applications. 
						  The data contained within a notification is structured arbitrarily, and typically only usable by the application which generated it in the first place.
						  In the spirit of Linked Data, we propose that notifications should be reusable by multiple authorised applications.
						  Through separating the concepts of <em>senders</em>, <em>receivers</em> and <em>consumers</em> of notifications, and leveraging Linked Data principles of shared vocabularies and URIs, LDN provides a building block for decentralised Web applications. This permits end users more freedom to switch between the online tools they use, as well as generating greater value when notifications from different sources can be used in combination. 
						  We situate LDN alongside related initiatives, and discuss additional considerations such as security and abuse prevention measures. 
						  We evaluate the protocol's effectiveness with multiple, independent implementations, which pass a suite of formal tests and can be demonstrated interoperating with each other. 
						  The canonical URI of this article is http://csarven.ca/linked-data-notifications</p>
                        </div>
                    </section>

                    <section id="keywords">
                        <h2>Keywords</h2>
                        <div>
                            <ul rel="schema:about">
                                <li><a href="https://en.wikipedia.org/wiki/Communications_protocol" resource="http://dbpedia.org/resource/Communications_protocol">Communications protocol</a></li>
                                <li><a href="https://en.wikipedia.org/wiki/Decentralization" resource="http://dbpedia.org/resource/Decentralization">Decentralisation</a></li>
                                <li><a href="https://en.wikipedia.org/wiki/Linked_data" resource="http://dbpedia.org/resource/Linked_data">Linked Data</a></li>
                                <li><a href="https://en.wikipedia.org/wiki/Social_web" resource="http://dbpedia.org/resource/Social_web">Social web</a></li>
                            </ul>
                        </div>
                    </section>

                    <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
                        <h2 property="schema:name">Introduction</h2>
                        <div datatype="rdf:HTML" property="schema:description">
							<p>Notifications are sent over the Web for a variety of purposes, including social applications: <q>You have been invited to a graduation party!</q>, <q>Tim commented on your blog post!</q>, <q>Somebody searched for you and is now following your profile</q>, <q>Liz tagged you in a photo</q>.
							The notification data may be displayed to a human to acknowledge, or used to trigger some other application-specific process (or both). 
                            In a decentralised architecture, notifications can be a key element for federation of information, and application integration.
							However in centralised systems which prevail today, this data is structured arbitrarily and typically only usable by the application that generated it in the first place.
							Current efforts towards <em>re-decentralising</em> the Web [<a href="http://crosscloud.org/2016/www-mansour-pdf.pdf"></a>, <a href="http://www.semantic-web-journal.net/sites/default/files/swj201_4.pdf"></a>, <a href="https://unhosted.org/"></a>] are moving towards architectures in which data storage is decoupled from application logic, freeing end users from switch between applications, or to let multiple applications operate over the same data.
							So far, notifications are considered to be <em>ephemeral</em> resources which may disappear after transport, and thus are excluded from being designed for reuse.</p>

                            <p>We argue that notification data should not be locked into particular systems. We designed the protocol <em>Linked Data Notifications (LDN)</em> to support sharing and reuse of notifications <em>across</em> applications, regardless of how they were generated or what their contents are. 
							We describe how the principles of identification, addressability and semantic representation can be applied to notifications on the Web.
							Specifying LDN as a formal protocol allows independently implemented, heterogeneous applications which generate and use notifications, to seamlessly work together. 
							Thus, LDN supports the decentralisation of the Web as well as encourages the generation and consumption of Linked Data.</p>

                            <p>We build on existing W3C standards and Linked Data principles. 
							In particular, the storage of notifications is compatible with the <cite>Linked Data Platform</cite> standard; notifications are identified by HTTP URIs; and notification contents must be available as JSON-LD.
							A key architectural decision is the separation of concerns between <em>senders</em>, <em>receivers</em>, and <em>consumers</em> of notifications. 
							Implementations of the protocol can play one or more of these roles, and interoperate successfully with implementations playing the complementary roles. 
							This means that notifications generated by one application can be reused by a completely different application, accessed via the store where the notification data resides, through shared Linked Data vocabularies.</p>

                            <p>LDN is a W3C <a href="https://www.w3.org/TR/ldn/">Candidate Recommendation</a> via the <a href="https://www.w3.org/wiki/Socialwg">Social Web Working Group</a>. The authors of this article: <a href="http://csarven.ca/#i">Sarven</a> and <a href="https://rhiaro.co.uk/#me">Amy</a>, are the co-editors of the specification.</p>

                            <p>In this article we present use cases for decentralised notifications from the Social Web and related domains, and describe the requirements which guided the development of the protocol. 
							We discuss related work in terms of predecessors to this work, comparisons with current alternative approaches, as well as complementary protocols which can work alongside LDN. 
							We summarise the protocol itself, and then go into detail about specific architectural considerations that were made. We built a test suite which can be used to confirm that implementations conform with the specification, and we describe the independent implementations which interoperate with each other so far.</p>

                            <div about="" id="concept-scheme" rel="schema:hasPart" resource="#concept-scheme">
                              <p resource="#concept-scheme" typeof="skos:ConceptScheme"><span property="skos:prefLabel">LDN Concept Scheme</span>: <span property="skos:definition">As the following terms used throughout this paper may be subject to different interpretations by different communities, we provide some definitions here.</span></p>

                                <dl rel="skos:hasTopConcept">
                                    <dt about="#concept-decentralisation" id="concept-decentralisation" property="skos:prefLabel" rel="skos:topConceptOf" resource="#concept-scheme" typeof="skos:Concept">Decentralisation</dt>
                                    <dd about="#concept-decentralisation" property="skos:definition">Data and applications are loosely coupled, and users are empowered to choose where their data is stored or held. 
									We focus on Web-based decentralisation, where content is transported over HTTP, and resources are identified with URIs.</dd>

                                    <dt about="#concept-inbox" id="concept-inbox" property="skos:prefLabel" rel="skos:topConceptOf" resource="#concept-scheme" typeof="skos:Concept">Inbox</dt>
                                    <dd about="#concept-inbox" property="skos:definition">A container or directory (attached to a Web resource) which is used to store and serve a collection of notifications.</dd>

                                    <dt about="#concept-notification" id="concept-notification" property="skos:prefLabel" rel="skos:topConceptOf" resource="#concept-scheme" typeof="skos:Concept">Notification</dt>
                                    <dd about="#concept-notification" property="skos:definition">A retrievable resource which returns RDF. 
									The contents of notifications are intended to describe a change in state of some other resource, or contain new information for the attention of a user or process, and may be subject to constraints of the Inbox it is contained in.</dd>
                                </dl>
                            </div>

                            <p>Using this article as the target for notifications, we welcome readers' feedback via LDN.</p>
                        </div>
                    </section>          


                    <section id="use-cases" inlist="" rel="schema:hasPart" resource="#use-cases">
                        <h2 property="schema:name">Use cases</h2>
                        <div datatype="rdf:HTML" property="schema:description">
                            <p>The high level use case is to have independently built applications to be able to generate and make use of notification data no matter how it was created or where it is stored. 
							Here we briefly discuss some of the use cases from different domains that can make use of Linked Data Notifications.</p>

                            <p><strong>Social Networks</strong>: Announcements of new status updates and blog posts from contacts can be delivered through notifications; private and public personal messages; new comments or annotations on content, as well as likes, shares, and bookmarks; invitations to events and RSVPs; moves in a game; or collaborative content creation updates.
							In particular for connecting different social networks or for realising a fully decentralised social network, federated cross-platform notifications are essential.</p>

                            <p><strong>Scholarly Communication</strong>: Academic articles, scientific reports, and their peer-reviews can be published online. 
							Notifications can inform the author of an academic article or the scientific community about a new review or contribution. 
							A notification can contain a concise description about what was reviewed and where the source can be found, when it was created, by whom, and the conditions under which it can be reused.
							Another use case for scholarly articles would be to notify an author when their work has been cited, in order to provide the means to build bidirectional connections between ideas, discoveries, and innovations, as well as their evolution.</p>

                            <p><strong>Change of State</strong>: Notifications can be used to capture provenance and state changes. 
							For instance, datasets have changesets which include deltas between resources; software or collaborative documents have versioning; applications detect dataset issues and recommend fixes; emergency broadcasts are made during disaster situations; weather forecasts; personal fitness progress; or scientific, experimental and statistical observations.
							For example, notifications can be used to disseminate scientific observations captured by systems, devices or sensors (e.g. telescope imagery, weather data) in a tailored and targeted manner to interested peer researchers. 
							Applications can customise the notification to contain a small, semantically represented unit of information capturing in particular the time and state of an event.</p>
                        </div>
                    </section>


                    <section id="related-work" inlist="" rel="schema:hasPart" resource="#related-work">
                        <h2 property="schema:name">Related Work</h2>
                        <div datatype="rdf:HTML" property="schema:description" resource="#related-work" typeof="deo:RelatedWork">

                            <section id="notification-mechanisms" rel="schema:hasPart" resource="#notification-mechanisms">
                                <h3 property="schema:name">Notification mechanisms</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>Here we review previous and ongoing efforts towards delivering notifications in a decentralised manner. Many systems which make use of notifications operate either in a completely centralised way, or are decentralised only in the sense that different instances of the <em>same</em> codebase need to interoperate; we restrict our review to mechanisms which do not expect the notification to be received or used only by the same software or platform which sent it.</p>

                                    <p>The contents of a notification is one of either: 1) URLs, indicating relations between Web resources, or 2) a ‚Äòfat ping‚Äô containing a blob of information. Semantic Pingback, Webmention, and Provenance Pingback follow the first form, and are also known as <cite>linkbacks</cite>, the suite of protocols that essentially allows Web documents to automatically reciprocate hyperlinks. This has the advantage that a verification mechanism can be tightly specified (the URL of the target must appear in the content of the source), but the disadvantage that notifications are only available for use cases involving Web publishing.</p>

                                    <p id="semantic-pingback-and-webmention"><strong>Semantic Pingback</strong> [<a href="http://www.informatik.uni-leipzig.de/~auer/publicatio/emanticPingback.pdf"></a>, <a href="https://www.w3.org/wiki/index.php?title=Pingback&amp;oldid=57876"></a>, <a href="http://www.semantic-web-journal.net/sites/default/files/swj201_4.pdf"></a>, <a href="http://events.linkeddata.org/ldow2016/papers/LDOW2016_paper_02.pdf"></a>] and <strong>Webmention</strong> [<a href="https://www.w3.org/TR/webmention"></a>] both update the original Pingback [<a href="http://www.hixie.ch/specs/pingback/pingback"></a>] mechanism by replacing the XML-RPC transport mechanism by a <code>x-www-form-urlencoded</code> request with two parameters (<code>source</code> and <code>target</code>). Resources which are the target for a notification advertise the respective receiving service or endpoint via a <code>Link</code> relation, either in HTTP headers or HTML. Semantic Pingback additionally enables discovery of the Pingback service where target is available as RDF. While the content at source may indicate (in any convention or serialisation format) the type of relation between the source and target URLs, this information about the relation is not transmitted to the receiver's endpoint; only the source and target URLs are sent. As such, there is also no way to distinguish between multiple potential mentions of the target at the source; this is left up to the receiver to interpret. Semantic Pingback does encourage generation of additional semantics about the relation(s) between the source and the target by processing the source as RDF if possible, and also defines specific ways for a receiving server to handle incoming pingback data in order to add the source data to an RDF knowledge base [<a href="https://aksw.github.io/SemanticPingback/"></a>]. Beyond verifying that the source does indeed contain the URL of the target, Webmention does not specify any further requirements of the receiving server; nor is it expected that ‚Äúmentions‚Äù are retrievable once they have been sent. </p>

                                    <p id="provenance-pingback">A <strong>Provenance Pingback</strong> endpoint is also advertised through an HTTP <code>Link</code> header, and accepts a list of URIs for provenance records describing uses of the resource [<a href="http://www.w3.org/TR/prov-aq/#provenance-pingback"></a>]. Provenance Pingback does not specify any further behaviour by the receiving server, but the contents at the URIs listed in the notification body are well-defined.</p>

                                    <p>There are also notification mechanisms which send more information than just URLs in the notification body; due to each mechanism's focused use case, the payload is restricted to a particular vocabulary.</p>

                                    <p><strong>DSNotify</strong> is a centralised service which crawls Linked Datasets and tracks changes to links (create, remove, move, update) with the specific use case of preserving link integrity between Linked Open Data resources. Third-party applications can register with the sending service to receive notifications of changes in the form of a specific XML payload [<a href="http://eprints.cs.univie.ac.at/81/1/2010_WWW_DSNotify.pdf"></a>, <a href="http://www.cibiv.at/~niko/dsnotify/"></a>]. Alternatively, with the <strong>sparqlPuSH</strong> service, users may input a SPARQL query, the results of which are the specific updates they are interested in. The query is run periodically by the service, and the results are converted to an RSS feed, which is sent to a PubSubHubbub  hub to which the user can subscribe [<a href="http://ceur-ws.org/Vol-699/Paper6.pdf"></a>]. The <strong>ResourceSync Change Notification</strong> specification also sends update notifications via a <abbr title="PubSubHubbub">PuSH</abbr> hub, this time with an XML payload based on the Sitemap format [<a class="ref" href="http://www.openarchives.org/rs/notification/1.0/notification"></a>].</p>

                                    <p>Each of these are notification mechanisms triggered by subscription requests. That is, a user must actively solicit messages from a particular service, rather than having a way for a service to select a notification target and autonomously discover where to send notifications to.</p>
                                </div>
                            </section>
                        </div>
                    </section>

                    <section id="requirements-and-design-considerations" inlist="" rel="schema:hasPart" resource="#requirements-and-design-considerations">
                        <h2 property="schema:name">Requirements and Design Considerations</h2>
                        <div datatype="rdf:HTML" property="schema:description">
                            <p>In this section we discuss our considerations for a Web notification protocol that conforms to the Linked Data design principles, as well as best practices for applications. 
							We use these considerations for establishing both concrete requirements and points of implementation-specific flexibility for the protocol in order to ensure interoperable application behaviour and consistent notification data exchange.</p>

                            <section id="modularity" inlist="" rel="schema:hasPart" resource="#modularity">
                                <h4 property="schema:name">R1 Modularity</h4>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>In order to encourage modularity of applications, it is important to differentiate between different classes of implementation of the protocol. 
                                    Two parties are involved in the creation of a notification: a <em>sender</em> which generates the notification data, and a <em>receiver</em> which stores the created resource. 
                                    We also have the role of a <em>consumer</em>, which reads the data of the notification and repurposes it in some way.
                                    A software implementation can of course play two or all three of these roles; the important part is that it need not. 
                                    A consuming application can read and use notification data without being concerned about ever sending or storing notifications itself.</p>
                                </div>
                            </section>

                            <section id="reusable-notifications" inlist="" rel="schema:hasPart" resource="#reusable-notifications">
                                <h4 property="schema:name">R2 Reusable notifications</h4>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>The relationship between the <em>consumer</em> and <em>receiver</em> roles is key to notifications being reusable. A consumer must be able to autonomously find the location of notifications for or about the particular resource it is interested in. To achieve this we place a requirement on the receiver to expose notifications it has been sent in such away to permit other applications to access them; and specify how any resource can advertise its receiving endpoint for consumers to discover. </p>
                                    <p>In order to promote fair use or remixing of notification contents, applications can incorporate rights and licensing information into the data. 
                                    Similarly, applications may include additional information on licensing of any resources which are referred from the notification. 
                                    The presence of this type of information is important for consumers to assess the usability of data.</p>
                                </div>
                            </section>

                            <section id="persistence-and-retrievability" inlist="" rel="schema:hasPart" resource="#persistence-and-retrievability">
                                <h4 property="schema:name">R3 Persistence and Retrievablity</h4>
                                <div datatype="rdf:HTML" property="schema:description">

									<p>There is a social expectation and technical arguments for ensuring the persistence of identifiers of Web resources [cooluris]. 
                                    This is inconsistent with the traditionally ephemeral nature of notifications.  
                                    Applications may benefit from referring to or reusing notifications if the notifications are known to be available in the long term, or indicate their expected lifespan [<a href="http://philarcher.org/diary/2013/uripersistence/"></a>, <a href="https://www.w3.org/TR/dwbp/#UniqueIdentifiers" title="Best Practice 9: Use persistent URIs as identifiers of datasets"></a>, <a href="https://tools.ietf.org/html/rfc7089"></a>].</p>

                                    <p>A <em>RESTful architecture</em> [<a class="ref" href=""></a>] is well suited for persistent notifications, as it involves organisation of atomic resources, their discovery and description, and a lightweight API for the <abbr title="create, read, update, and delete">CRUD</abbr> (create, read, update, and delete) operations [<a href="http://ws-rest.org/2011/proc/a5-page.pdf">LD&amp;REST</a>].
                                    This enforces the notion that notifications are considered resources in their own right, with their own dereferencable URIs.
                                    </p>

                                    <p>We need to consider both the needs of software systems and humans when large amounts of notification data are being generated and shared between diverse applications which may be operating without knowledge of each other.
                                    In order to organise and manage large amount of notifications over time, mechanisms should be in place to break representations of collections of notifications into multiple paged responses that may be easier to consume by applications.</p>

                                    <p>Relatedly, receivers may carry out resource management or garbage collection, or permit consumers or other applications to do so. 
                                    For example, an application to consume messages might let an authenticated and authorised user ‚Äòmark as read‚Äô by adding a triple to the notification contents.</p>
                                </div>
                            </section>

                            <section id="adaptability" rel="schema:hasPart" resource="#adaptability">
                                <h4 property="schema:name">R4 Adaptability</h4>
                                <div datatype="rdf:HTML" property="schema:description">

                                    <p>Linked Data applications benefit from domain-driven designs; that is, functionality being small and focussed on a particular purpose, rather than generic. We believe a notification protocol should be adaptable for different domains, but that there is no need to create multiple domain-specific notification protocols; the fundamental mechanics are the same.</p>

                                    <p><strong>R4-A</strong>: Any resource may be the <em>target</em> of a notification. By target, we mean a notification may be addressed <em>to</em> the resource, be <em>about</em> the resource, or for a sender to otherwise decide that it is appropriate to draw the attention of the resource (or resource owner) to the information in the notification body. As such, any Web resource must be able to advertise an endpoint to which it can receive notifications. Resources can be RDF or non-RDF (such as an image, or CSV dataset), and may be informational (a blog post, a user profile) or non-informational (a person).</p>

                                    <p><strong>R4-B</strong>:  
                                    We do not purport to be able to design a notifications ontology which is appropriate for every domain. Thus we consider the <em>contents</em> of a notification to be application specific. 
                                    From a sender's perspective, we derive two core principles:
                                    a notification can contain <em>any data</em>;
                                    a notification can use <em>any vocabulary</em>.
                                    From a consumer's perspective, interoperability between different applications occurs through vocabulary reuse, and shared understanding of terms. 
                                    This is in accordance with Linked Data principles in general. 
                                    The practical upshot of this is that a calendar application which consumes event invitations using the <cite><a href="https://www.w3.org/TR/rdfcal/">RDF Calendar</a></cite> vocabulary is likely to completely ignore notifications containing the <cite><a href="http://schema.org/">schema.org</a></cite> vocabulary, even if it finds them all stored in the same place.
                                    For two independent applications operating in the <em>same</em> domain, a shared understanding of appropriate vocabulary terms is assumed.</p>

                                    <p>However from a receiver's perspective, exposing itself to receive any blobs of RDF data from unknown senders may be problematic. 
                                    Thus, <strong>R4-C</strong>: it should be possible for the receiver to enforce restrictions and accept only notifications that are acceptable according to its own criteria (deemed by e.g., user configuration; domain-specific receivers). 
                                    This can be used as an anti-spam measure, a security protection, or for attaining application and data integrity.</p>

                                    <p>A possible filtering mechanism is rejecting notifications which do not match a specific pattern in their contents, or the <em>shape</em> of the data, in order to allow a certain class of applications consume them.
                                    For example, if the Inbox owner knows that they will only ever use a consuming application which processes friend requests, they can configure their receiver to filter out anything that doesn't match the pattern for a friend request, helping their consumer to be more efficient.
                                    If the notification constraints are also advertised by the receiving service as structured descriptions, generation and consumption of the notifications can be further automated.
                                    Possible specifications for doing so are <cite><a href="https://www.w3.org/TR/shacl/">SHACL</a></cite> or <cite><a href="https://shexspec.github.io/spec/">ShEx</a></cite>.</p>

                                    <p>Receivers may wish to filter notifications by verifying the sender, through for example a whitelist or a web of trust. 
                                    This requires an authentication mechanism and since different authentication mechanisms are appropriate for different applications, the notification protocol should ideally be usable alongside various methods such as clientside certificates (e.g. WebID+TLS), token-based (e.g. OAuth 2.0), or digital signatures. 
                                    </p>

                                    <p>As <q>anyone can say anything about anything</q> a receiver may choose to dereference any external resources referred to by the notification, and cross-check the notification contents against authoritative sources.
                                    This is similar to how Semantic Pingback and Webmention require fetching and parsing of the source URL to verify existence of the target link.</p>
                                </div>
                            </section>

                            <section id="subscribing" inlist="" rel="schema:hasPart" resource="#subscribing">
                                <h4 property="schema:name">R5 Subscribing</h4>
                                <div datatype="rdf:HTML" property="schema:description">

                                    <p>In general, applications may require that new notifications are pushed to them in real-time, or to request them at appropriate intervals. 
                                    To take this into account, we expand our definition of senders, receivers and consumers with the following interaction expectations: </p>
                                    <ul>
                                        <li>Notifications are <em>pushed</em> from senders to receivers;</li>
                                        <li>and <em>pulled</em> from receivers by consumers.</li>
                                    </ul>

                                    <p>Thus, an application which offers an endpoint or callback URL to which notifications should be sent directly is a receiver, and an application which fetches notifications from an endpoint on its own schedule is a consumer.
                                    Much of the related work <em>requires</em> notifications to be explicitly solicited in order to trigger sending. Since in a decentralised model, receivers may not be aware of possible sources for notifications, our sender-receiver relationship depends on the sender's autonomy to make such decisions by itself. 
                                    This does not preclude the scenario in which a receiver may wish to solicit notifications from a particular sender, but as there are already subscription mechanisms in wide use on the Web, we do not need to specify it as part of LDN. For example, WebSub<sup><a href="#fn-websub">w</a></sup>, the WebSocket Protocol, or HTTP Web Push can be used.</p>

                                </div>
                            </section>

                            <p>Given our adoption of Linked Data principles and a RESTful architecture, a further design decision we made was to ensure minimal compatibility with the <em>Linked Data Platform</em> (LDP) specification [<a class="ref" href=""></a>]. LDP is a RESTful read-write API for RDF resources, which groups related resources together into constructs known as <em>Containers</em>. Thus, existing LDP servers can be used to store notifications, as new notifications can be created by <code>POST</code>ing RDF to a Container.</p>
 
                            <p><sup id="fn-websub">w. WebSub is a recent W3C evolution of PubSubHubbub.</sup></p>
                        </div>
                    </section>

                    <section id="protocol" inlist="" rel="schema:hasPart" resource="#protocol">
                        <h2 property="schema:name">The LDN Protocol</h2>
                        <div datatype="rdf:HTML" property="schema:description" resource="#protocol" typeof="deo:Contribution">
                            <p>The <dfn id="ldn">Linked Data Notifications (<abbr title="Linked Data Notifications">LDN</abbr>)</dfn> protocol describes how servers (receivers) can receive messages pushed to them by applications (senders), as well as how other applications (consumers) may retrieve those messages. 
							Any resource can advertise a receiving endpoint (Inbox) for notification messages. 
							Messages are expressed in RDF, and can contain arbitrary data.
							An LDN receiver can be considered a specialisation of Linked Data Platform [<cite><a class="bibref" href="#bib-ldp">LDP</a></cite>]. 
							It is not dependent on a complete implementation of LDP, but comprises an easy-to-implement subset. 
							LDN is a <a href="https://www.w3.org/TR/ldn">W3C Candidate Recommendation</a> [<cite><a class="bibref" href="#bib-ldn">LDN</a></cite>].</p>

                            <figure id="figure-linked-data-notifications-overview" rel="schema:hasPart" resource="#figure-linked-data-notifications-overview">
                                <object data="media/images/linked-data-notifications-overview.svg" height="200" rel="schema:image" type="image/svg+xml" width="420"></object>

                                <figcaption property="schema:name">Overview of Linked Data Notifications</figcaption>
                            </figure>

                            <section id="sender-to-receiver" inlist="" rel="schema:hasPart" resource="#sender-to-receiver">
                                <h3 property="schema:name">Sender to receiver interactions</h3>
                                <div datatype="rdf:HTML" property="schema:description">
									<p>The following steps describe the interaction between sender and receiver:</p>
                                    <ol>
                                        <li>A sender is triggered, either by a human or an automatic process, to deliver a notification.</li>
                                        <li>The sender chooses a target resource to send notifications to.</li>
                                        <li>The sender discovers the location of the target‚Äôs <em>Inbox</em> through the <code>ldp:inbox</code> relation in the HTTP <code>Link</code> header or RDF body of the target resource.</li>
                                        <li>The sender creates the body of the notification according to the needs of application.</li>
                                        <li>The sender makes a <code>POST</code> request to the Inbox URL, containing the body in JSON-LD or in another serialisation acceptable by the server.</li>
                                        <li>The receiver optionally applies filtering rules, and sends the appropriate HTTP response code to accept or reject the notification.</li>
                                        <li>The receiver exposes the notification data (according to appropriate access control) for use by consumers.</li>
                                    </ol>
                                </div>
                            </section>

                            <section id="consumer-to-receiver" inlist="" rel="schema:hasPart" resource="#consumer-to-receiver">
                                <h3 property="schema:name">Consumer to receiver interactions</h3>
                                <div datatype="rdf:HTML" property="schema:description">
									<p>The following steps describe the interaction between consumer and receiver:</p>
                                    <ol>
                                        <li>A consumer selects a target and discovers the location of its Inbox in the same way as the sender.</li>
                                        <li>A receiver responds to <code>GET</code> requests made to the Inbox URL with a listing of the URLs of notifications that have previously been accepted, linked to the Inbox with the <code>ldp:contains</code> predicate.</li>
                                        <li>The receiver responds to <code>GET</code> requests made to the individual notification URLs with JSON-LD (or optionally other serialisations).</li>
                                        <li>Following the retrieval of notification listings or individual notifications, the consumer may perform further processing, combine with some other data, or simply present the results in a suitable human-readable way.</li>
                                    </ol>
                                </div>
                            </section>

                            <section id="data-formats" inlist="" rel="schema:hasPart" resource="#data-formats">
                                <h3 property="schema:name">Data Formats and Content Negotiation</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>Whilst being able to handle data irrespective of the particular RDF serialisation permits some flexibility, this can be costly to support. 
									From the perspective of the protocol design, we must take into account:</p>

                                    <ul>
                                        <li>application interoperability,</li>
                                        <li>maintenance of the RDF parsers and serialisation libraries,</li>
                                        <li>complexity of their inclusion in applications,</li>
                                        <li>run-time efficiency.</li>
                                    </ul>

                                    <p>In order to address these issues, LDN requires all applications to create and understand the JSON-LD syntax, both for looking at the contents of Inbox as well as for individual notifications. 
                                    Choosing a single serialisation which implementations <em>must</em> work with is necessary for consistent interoperability, as well as keeping processing requirements or external dependencies of codebases minimal.
									JSON-LD is advantageous in being familiar for developers who are used to JSON-based APIs but not RDF [<a href="http://manu.sporny.org/2014/json-ld-origins-2/"></a>], and it is compatible with existing JSON libraries or in some cases native programming language data structures.
									Optionally, applications may perform content negotiation (receivers can expose <code>Accept-Post</code> headers for senders, and consumers can send <code>Accept</code> headers to receivers) in order to attempt to exchange different RDF serialisations if desired.</p>

                                </div>
                            </section>

                            <section id="example-notifications" inlist="" rel="schema:hasPart" resource="#example-notifications">
                                <h3 property="schema:name">Example Notifications</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>Here we present example notification payloads. Please refer to the <a href="https://www.w3.org/TR/ldn/">W3C LDN specification</a> for examples of HTTP requests and responses for the other interactions between senders, receivers and consumers.</p>

                                    <figure class="listing" id="sending-notification-request" rel="schema:hasPart" resource="#sending-notification-request">
                                        <pre about="#sending-notification-request" property="schema:description" typeof="fabio:Script">
<code>POST /inbox/ HTTP/1.1</code>
<code>Host: example.org</code>
<code>Content-Type: application/ld+json</code>
<code>Content-Language: en</code>
<code></code>
<code>{</code>
<code>  "@context": {</code>
<code>    "@language": "en",</code>
<code>    "sioc": "http://rdfs.org/sioc/ns#",</code>
<code>    "foaf": "http://xmlns.com/foaf/0.1/"</code>
<code>  },</code>
<code>  "@id": "",</code>
<code>  "@type": "sioc:Comment",</code>
<code>  "sioc:content": "This is a great article!",</code>
<code>  "sioc:reply_of": { "@id": "http://example.org/article" },</code>
<code>  "sioc:created_at": {</code>
<code>    "@type": "http://www.w3.org/2001/XMLSchema#dateTime",</code>
<code>    "@value": "2015-12-23T16:44:21Z"</code>
<code>  },</code>
<code>  "sioc:has_creator": {</code>
<code>    "@id": "http://example.org/profile",</code>
<code>    "@type": "sioc:UserAccount",</code>
<code>    "sioc:account_of": { "@id": "http://example.org/profile#alice" },</code>
<code>    "sioc:avatar": { "@id": "http://example.org/profile/avatar.png" },</code>
<code>    "foaf:name": "Alice"</code>
<code>  }</code>
<code>}</code>
                                        </pre>
                                        <figcaption property="schema:name">This notification body contains information about a comment and the user who created the comment, described by the Semantically Interlinked Online Communities (SIOC) and Friend-of-a-Friend (FOAF) vocabularies.</figcaption>
                                    </figure>

                                    <figure class="listing" id="notification-qualified-relation" rel="schema:hasPart" resource="#notification-qualified-relation">
                                        <pre about="#notification-qualified-relation" property="schema:description" typeof="fabio:Script">
<code>POST /inbox/ HTTP/1.1</code>
<code>Host: csarven.ca</code>
<code>Content-Type: text/turtle</code>
<code>Content-Language: en</code>
<code></code>
<code>@prefix as: &lt;https://www.w3.org/ns/activitystreams#&gt; .</code>
<code>@prefix cito: &lt;http://purl.org/spar/cito/&gt; .</code>
<code></code>
<code>&lt;&gt; a as:Announce</code>
<code>  as:object &lt;https://linkedresearch.org/resources#r-903b83&gt; ;</code>
<code>  as:target &lt;http://csarven.ca/dokieli#architecture&gt; ;</code>
<code>  as:updated "2016-12-05T23:53:27.436Z"^^xsd:dateTime .</code>
<code></code>
<code>&lt;https://linkedresearch.org/resources#r-903b83&gt;</code>
<code>  cito:citesAsPotentialReading</code>
<code>    &lt;http://csarven.ca/dokieli#architecture&gt; .</code></pre>
                                        <figcaption property="schema:name">This notification body conveys an announcement of a URL that the target resource should be aware of. It includes the specific relation between the announced URL and the target (the former cites the latter).</figcaption>
                                    </figure>
                                </div>
                            </section>
                        </div>
                    </section>

                    <section id="implementations" inlist="" rel="schema:hasPart" resource="#implementations">
                        <h2 property="schema:name">Implementations</h2>
                        <div datatype="rdf:HTML" property="schema:description">
                            <p>Here we summarise the 16 LDN implementations we are aware of to date. They are built by 9 different teams or individuals using different tool stacks (5 clientside JavaScript, 3 PHP, 3 NodeJS, 2 Python, 1 Perl, 1 C/C++) and have submitted implementation reports<sup><a href="https://github.com/w3c/ldn/tree/master/implementations">x</a></sup> as part of the W3C standardisation process. 
                            We note that any <a href="https://www.w3.org/wiki/LDP_Implementations">LDP implementation</a> is a conforming LDN receiver; we refer here to the ones we have tested.</p>

                            <table>
                                <caption>LDN Implementations</caption>
                                <thead>
                                    <tr>
                                        <th>Name and URL</th>
                                        <th>Class<sup><a href="#implementations-key">*</a></sup></th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tfoot><tr>
                                    <td colspan="3">
                                        <p><sup id="implementations-key">*</sup> Conformance classes: S ‚Äì sender, C ‚Äì consumer, R ‚Äì receiver.</p>
                                        <p><sup id="author-implementations">a</sup> Implementations by the authors.</p>
                                    </td>
                                </tr></tfoot>
                                <tbody>
                                    <tr>
                                        <th><a href="https://carbonldp.com">CarbonLDP</a></th>
                                        <td>R</td>
                                        <td>Data storage platform (LDP-based)</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://dokie.li/">dokieli</a><sup>a</sup></th>
                                        <td>S,C</td>
                                        <td>Clientside article editor and annotation tool</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/linkeddata/errol">errol</a><sup>a</sup></th>
                                        <td>S</td>
                                        <td>Generic message sending client</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/Kongaloosh/IndieAnndroid">IndieAnndroid</a></th>
                                        <td>R</td>
                                        <td>Personal blogging platform</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/albertmeronyo/linked-edit-rules">Linked Edit Rules</a></th>
                                        <td>S</td>
                                        <td>Statistical dataset consistency checker</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/csarven/mayktso">mayktso</a><sup>a</sup></th>
                                        <td>R</td>
                                        <td>Personal data store (LDP-based)</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/rhiaro/onscreen">OnScreen</a><sup>a</sup></th>
                                        <td>C</td>
                                        <td>Generic notifications display client</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/albertmeronyo/pyldn">pyldn</a></th>
                                        <td>R</td>
                                        <td>Standalone Inbox</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/kjetilk/p5-rdf-linkeddata-notifications">RDF::LinkedData::Notifications</a></th>
                                        <td>R</td>
                                        <td>Standalone Inbox</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/rhiaro/sloph">sloph</a><sup>a</sup></th>
                                        <td>S,R</td>
                                        <td>Personal publishing, quantified self, and social platform</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/melvincarvalho/vocab">Solid Words</a></th>
                                        <td>S</td>
                                        <td>Foreign language learning app</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/solid/solid-client">solid-client</a></th>
                                        <td>S</td>
                                        <td>Clientside library for interfacing with LDP servers</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/solid/solid-inbox">solid-inbox</a></th>
                                        <td>C</td>
                                        <td>Clientside social message reader</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/solid/solid-notifications">solid-notifications</a></th>
                                        <td>S,C</td>
                                        <td>Clientside library for LDN</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/solid/node-solid-server">solid-server</a></th>
                                        <td>R</td>
                                        <td>Personal data storage server (LDP-based)</td>
                                    </tr>
                                    <tr>
                                        <th><a href="https://github.com/openlink/virtuoso-opensource">Virtuoso</a>+<a href="http://ods.openlinksw.com/wiki/ODS/OdsBriefcase">ODS Briefcase</a></th>
                                        <td>R,C</td>
                                        <td>Personal data storage server (LDP-based)</td>
                                    </tr>
                                </tbody>
                            </table>

                            <p>We highlight some social scholarly communication use cases with <cite><a href="https://dokie.li/">dokieli</a></cite> ‚Äì a clientside editor for decentralised article publishing, annotations and social interactions [<a href="http://csarven.ca/dokieli"></a>]. dokieli is a domain-specific application that uses LDN to send and consume notifications for various purposes:</p>

                            <ul>
                                <li>When a reader comments on a specific fragment of text in an article using dokieli, the application discovers the article's inbox and sends a notification about the annotation. dokieli also consumes notifications from this Inbox to fetch and display the annotation source data as marginalia (figure 2).</li>
                                <li>A reader can share a dokieli-enabled article with their contacts; dokieli discovers an Inbox for each contact's profile URL and sends a notification there (figure 3).</li>
                                <li>When editing an article, the author can add a citation. If an Inbox is discovered in the cited article, dokieli sends a notification there to indicate what part of the article was cited by whom and where. dokieli-enabled articles also consume citation notifications to display these metrics for the author and other readers (figure 4).</li>
                            </ul>

                            <figure id="figure-dokieli-annotation" rel="schema:hasPart" resource="#figure-dokieli-annotation">
                                <video id="video-dokieli-annotation" rel="schema:hasPart" preload="none" controls="controls" width="800" poster="https://dokie.li/media/images/dokieli-annotation.jpg">
                                    <source about="#video-dokieli-annotation" rel="schema:hasPart" resource="https://dokie.li/media/video/dokieli-annotation.webm" typeof="fabio:Film" src="https://dokie.li/media/video/dokieli-annotation.webm" type="video/webm" />
                                </video>
                                <figcaption property="schema:name"><a href="https://dokie.li/media/video/dokieli-annotation.webm">Video</a> of dokieli Web Annotation</figcaption>
                            </figure>

                            <figure id="figure-dokieli-share" rel="schema:hasPart" resource="#figure-dokieli-share">
                                <video id="video-dokieli-share" rel="schema:hasPart" preload="none" controls="controls" width="800" poster="https://dokie.li/media/images/dokieli-share.jpg">
                                    <source about="#video-dokieli-share" rel="schema:hasPart" resource="https://dokie.li/media/video/dokieli-share.webm"  typeof="fabio:Film" src="https://dokie.li/media/video/dokieli-share.webm" type="video/webm" />
                                </video>
                                <figcaption property="schema:name"><a href="https://dokie.li/media/video/dokieli-share.webm">Video</a> of dokieli Share</figcaption>
                            </figure>

                            <figure id="figure-dokieli-citation" rel="schema:hasPart" resource="#figure-dokieli-citation">
                                <video controls="controls" id="video-dokieli-citation" poster="https://dokie.li/media/images/dokieli-citation.jpg" preload="none" width="800" about="" rel="schema:hasPart">
                                    <source about="#video-dokieli-citation" rel="schema:hasPart" resource="https://dokie.li/media/video/dokieli-citation.webm" src="https://dokie.li/media/video/dokieli-citation.webm" type="video/webm" typeof="fabio:Film" />
                                </video>
                                <figcaption property="schema:name"><a href="https://dokie.li/media/video/dokieli-citation.webm">Video</a> of semantic inline citations</figcaption>
                            </figure>

                            <p>Notifications sent by dokieli can be reused by any consuming applications which recognise the vocabulary terms; similarly, dokieli can consume notifications that were sent by a different application. </p>

                            <p>Further social use cases are demonstrated by <a href="https://rhiaro.co.uk/sloph">sloph</a>, a personal publishing and quantified self platform which acts as a node in a decentralised social network. When a new piece of content is created on the server, sloph performs discovery on URLs it finds as values of particular properties of the generated data (according to <a href="https://www.w3.org/TR/activitypub">ActivityPub</a>; cf.¬†the <a href="#compatibility-with-existing-systems">Compatibility</a> section) as well as any URLs in the body of the content and sends notifications accordingly. For instance:</p>
                            <ul>
                                <li>If the user generates an ActivityStreams 2.0 <em>Like</em> activity on their server, sloph uses the <code>object</code> of the <em>Like</em> as the target for a notification. Since dokieli also uses the ActivityStreams 2.0 vocabulary for social interactions, if the target is a dokieli article, this <em>Like</em> will be displayed (figure 5).</li>
                                <li>If the user publishes a blog post containing a link, which may be semantically annotated to indicate the reason for linking, sloph sends a notification to any Inbox discovered at that link.</li>
                                <li>As a receiver, sloph accepts all incoming notifications, but holds for moderation (ie. places behind access control) any that it cannot automatically verify refer to third-party content published on another domain. If an article written with dokieli publishes a citation of a blog post which advertises a sloph Inbox, sloph will fetch the article and verify whether the relation matches the contents of the notification before exposing the notification for re-use.</li>
                            </ul>

                            <p><a href="http://www.linkededitrules.org/">Linked Edit Rules</a> and <a href="https://melvincarvalho.github.io/vocab/">Solid Words</a> are specialised senders. Linked Edit Rules checks the consistency of statistical datasets against structured constraints, and delivers the consistency report as a notification to the user. Solid Words is a clientside game for learning new words in a foreign language; it delivers the player's score for each round to their Inbox. <a href="https://apps.rhiaro.co.uk/onscreen">OnScreen</a> is a (crude) generic consumer; as such, it can display notifications sent by both of the aforementioned senders (figure 6).</p>

                            <figure id="figure-sloph" rel="schema:hasPart" resource="#figure-sloph">
                                <img src="" />
                                <figcaption property="schema:name">A <em>Like</em> notification created by Sloph, displayed by dokieli.</figcaption>
                            </figure>

                            <figure id="figure-senders-onscreen" rel="schema:hasPart" resource="#figure-senders-onscreen">
                                <img src="media/images/sender-consumer-screenshots.png" alt="Screenshots of Solid Words, Linked Edit Rules, and OnScreen" />
                                <figcaption property="schema:name">A: Solid Words (a sender), B: Linked Edit Rules (a sender), C: OnScreen (a consumer) displaying notifications sent by A and B.</figcaption>
                            </figure>
                        </div>
                    </section>

                    <section id="analysis-and-evaluation" rel="schema:hasPart" resource="#analysis-and-evaluation">
                        <h2 property="schema:name">Analysis and Evaluation</h2>
                        <div datatype="rdf:HTML" property="schema:description" typeof="deo:Evaluation">
                            <p>At its core, the LDN protocol describes the discovery of a resource's Inbox whence notifications are sent or consumed, and the sending and exposure of those notifications. In this section we analyse how well features of LDN achieve the <a href="#requirements-and-design-considerations">requirements</a> identified previously, and compare this to related work.</p>  
                            <p>We have already examined <a href="#implementations">implementations</a> of the specification, and described how they interoperate. We can use this to some extent as an evaluation of its feasibility and effectiveness at interoperability. Given the relatively early stage in the standardisation process (LDN entered Candidate Recommendation on the 1st of November 2016), the quantity of implementations and diversity of their sources is promising.</p>

                            <p>Additionally during the development of the specification issues have been raised or discussed by 28 different people (not including the authors; 21 outside of the Social Web Working Group, 7 within) and the specification has undergone formal review by internationalisation, accessibility, and security specialists. We discuss in more depth particular challenges that were raised and resolved as part of this process in this section too.</p>

                            <section id="comparison-summary" rel="schema:hasPart" resource="#comparison-summary">
                                <h3 property="schema:name">Comparison summary</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                  <p>Here we compare existing notification mechanisms from related work. The criteria from the <a href="#requirements-and-design-considerations">requirements and design considerations</a> are included (denoted by <em>Rx</em>) along with additional technical information which helps to capture some of the differences in their designs (denoted by <em>Tx</em>).</p>

                                    <table id="comparison-of-notification-mechanisms">
                                        <caption>Comparison of notification mechanisms</caption>
                                        <thead>
                                            <tr>
                                                <th>Mechanism</th>
                                                <th>T1</th>
                                                <th>T2</th>
                                                <th>R1</th>
                                                <th>R2</th>
                                                <th>R3</th>
                                                <th>R4A</th>
                                                <th>R4B</th>
                                                <th>R4Cp</th>
                                                <th>R4Cv</th>
                                                <th>R4Co</th>
                                                <th>R5</th>
                                                <th>T3</th>
                                            </tr>
                                        </thead>
                                        <tfoot>
                                            <tr>
                                                <td colspan="14">
                                                    <dl class="abbr">
                                                        <dt>T1</dt><dd>Notification type</dd>
                                                        <dt>T2</dt><dd>Delivery method</dd>
                                                        <dt>R1</dt><dd>Modularity (application classes defined - S Sender, R Receiver, C Consumer, U Subscriber/User)</dd>
                                                        <dt>R2</dt><dd>Reusability</dd>
                                                        <dt>R3</dt><dd>Persitence (if required, how?)</dd>
                                                        <dt>R4A</dt><dd>Adaptability (target representation)</dd>
                                                        <dt>R4B</dt><dd>Adaptability (notification body)</dd>
                                                        <dt>R4C<sup>p</sup></dt><dd>Adaptability (payload processing required?)</dd>
                                                        <dt>R4C<sup>v</sup></dt><dd>Adaptability (verification - required? how?)</dd>
                                                        <dt>R4C<sup>o</sup></dt><dd>Adaptability (requirements for other referenced resources?)</dd>
                                                        <dt>R5</dt><dd>Subscription</dd>
                                                        <dt>T3</dt><dd>Dependencies</dd>
                                                    </dl>
                                                    <hr/>
                                                    <dl class="abbr">
                                                        <dt>-</dt><dd>not applicable, out of scope</dd>
                                                        <dt>/</dt><dd>not specified, in scope</dd>
                                                        <dt>X</dt><dd>explicitly disallowed</dd>
                                                        <dt>app</dt><dd>application specific decision</dd>
                                                        <dt>!</dt><dd>required (<em>MUST</em>)</dd>
                                                        <dt>+</dt><dd>recommended (<em>SHOULD</em>)</dd>
                                                        <dt>O</dt><dd>optional (<em>MAY</em>)</dd>
                                                        <dt>PuSH</dt><dd>PubSubHubbub</dd>
                                                    </dl>
                                                    <hr/>
                                                    <dl class="abbr">
                                                        <dt><sup>h</sup></dt><dd>HTML recommended</dd>
                                                        <dt><sup>j</sup></dt><dd>JSON-LD is required, alternative RDF representations can be negotiated.</dd>
                                                        <dt><sup>k</sup></dt><dd>key‚Äìvalue pairs for <code>source</code> and <code>target</code> are required</dd>
                                                        <dt><sup>q</sup></dt><dd>Provenance records with <a href="http://www.w3.org/TR/prov-o/">PROV Ontology</a></dd>
                                                        <dt><sup>r</sup></dt><dd>RDF representation recommended</dd>
                                                        <dt><sup>ra</sup></dt><dd>SPARQL results transformed to RSS/Atom</dd>
                                                        <dt><sup>s</sup></dt><dd><a href="https://www.sitemaps.org/protocol.html">Sitemaps</a></dd>
                                                        <dt><sup>t</sup><dd>Described in an RDF store or dataset</dd>
                                                    </dl>
                                                </td>
                                                <!-- Notes for how I removed some ?s:
                                                    * target representation is - when there's no discovery step for the sender ie. subscription based

                                                    * verification required is - when there's a subscription relationship because we assume the receiver trusts the sender
                                                -rhiaro -->
                                            </tr>
                                        </tfoot>
                                        <tbody>
                                            <tr>
                                                <th>Semantic Pingback</th>
                                                <td>Linkback</td>
                                                <td>POST</td>
                                                <td>S R</td>
                                                <td>/</td>
                                                <td>/</td>
                                                <td>Any<sup>r</sup></td>
                                                <td>form urlencoded<sup>k</sup></td>
                                                <td>!</td>
                                                <td>! parse source</td>
                                                <td>Any<sup>r</sup></td>
                                                <td>X</td>
                                                <td>RDF</td>
                                            </tr>
                                            <tr>
                                                <th>Webmention</th>
                                                <td>Linkback</td>
                                                <td>POST</td>
                                                <td>S R</td>
                                                <td>-</td>
                                                <td>-</td>
                                                <td>Any<sup>h</sup></td>
                                                <td>form urlencoded<sup>k</sup></td>
                                                <td>!</td>
                                                <td>! parse source</td>
                                                <td>Any<sup>h</sup></td>
                                                <td>X</td>
                                                <td>HTML</td>
                                            </tr>
                                            <tr>
                                                <th>Provenance Pingback</th>
                                                <td>Linkback</td>
                                                <td>POST</td>
                                                <td>S R</td>
                                                <td>/</td>
                                                <td>/</td>
                                                <td>/</td>
                                                <td>URI list</td>
                                                <td>/</td>
                                                <td>/</td>
                                                <td>RDF<sup>q</sup></td>
                                                <td>X</td>
                                                <td>RDF</td>
                                            </tr>
                                            <tr>
                                                <th>DSNotify</th>
                                                <td>Fat ping</td>
                                                <td>POST, PUT</td>
                                                <td>S U</td>
                                                <td>/</td>
                                                <td>-</td>
                                                <td>-</td>
                                                <td>XML</td>
                                                <td>/</td>
                                                <td>-</td>
                                                <td>RDF<sup>t</sup></td>
                                                <td>!</td>
                                                <td>XML, PuSH</td>
                                            </tr>
                                            <tr>
                                                <th>sparqlPuSH</th>
                                                <td>Fat ping</td>
                                                <td>POST</td>
                                                <td>S U</td>
                                                <td>-</td>
                                                <td>-</td>
                                                <td>-</td>
                                                <td>XML<sup>ra</sup></td>
                                                <td>/</td>
                                                <td>-</td>
                                                <td>RDF<sup>t</sup></td>
                                                <td>!</td>
                                                <td>XML, SPARQL, PuSH</td>
                                            </tr>
                                            <tr>
                                                <th>ResourceSync</th>
                                                <td>Fat ping</td>
                                                <td>POST</td>
                                                <td>S U</td>
                                                <td>/</td>
                                                <td>-</td>
                                                <td>-</td>
                                                <td>XML<sup>s</sup></td>
                                                <td>/</td>
                                                <td>-</td>
                                                <td>?</td>
                                                <td>!</td>
                                                <td>XML, PuSH</td>
                                            </tr>
                                            <tr>
                                                <th>Linked Data Notifications</th>
                                                <td>Fat ping</td>
                                                <td>POST</td>
                                                <td>S R C</td>
                                                <td>!</td>
                                                <td>! URI</td>
                                                <td>Any</td>
                                                <td>JSON-LD<sup>j</sup></td>
                                                <td>+ app</td>
                                                <td>+ app</td>
                                                <td>-</td>
                                                <td>O app</td>
                                                <td>JSON-LD</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </section>

                            <section id="compatibility-with-existing-systems" rel="schema:hasPart" resource="#compatibility-with-existing-systems">
                                <h3 property="schema:name">Compatibility with existing systems</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>We intentionally take a bare minimum approach, preferring to suggest using LDN alongside other existing protocols and standards rather than re-specifying already standardised mechanisms for non-core behaviours. This has the advantage of resulting in a protocol which can serve as a module of a larger system, accompanied by other protocols according to the needs of the environment (R1 Modularity, R4 Adaptability). Examples include (listed with implementations that already use these protocols alongside LDN):</p>
                                    <ul>
                                        <li><cite><a href="https://www.w3.org/wiki/WebAccessControl">Web Access Control</a></cite> can be used along with an authentication mechanism to apply fine grained access controls to restrict who can send notifications, or who can retrieve notifications from the Inbox (used by the Solid suite of tools, and dokieli).</li>
                                        <li><cite><a href="https://www.w3.org/TR/websub/">WebSub</a></cite> can be used by a receiver to issue a subscription request to a sender's hub in order to trigger the sender to push notifications on a particular topic.</li>
                                        <li>An Inbox can double as a <cite><a href="http://www.webhooks.org/">Webhooks</a></cite> callback URL, in order to request notifications from applications which post JSON-based payloads (used by sloph).</li>
                                        <li><cite><a href="https://www.w3.org/TR/activitypub/">ActivityPub</a></cite> is a W3C Candidate Recommendation for decentralised social media applications based on the <a href="https://www.w3.org/ns/activitystreams-vocabulary">ActivityStreams 2.0</a> (AS2) vocabulary. ActivityPub directly references LDN for delivery of notifications, with the additional requirement that notification contents are AS2. It also specifies additional behaviour for a receiver upon receiving notifications in order to propagate information through the social network (used by sloph).</li>
                                        <li><cite><a href="https://www.w3.org/TR/shacl/">SHACL</a></cite>/<cite><a href="https://shexspec.github.io/spec/">ShEx</a></cite> can be used to define the constraints of notification shape.</li>
                                        <li><cite><a href="https://www.w3.org/TR/annotation-protocol/">Web Annotation Protocol</a></cite> is an LDP-based mechanism for creating new content, which can be a trigger for notifications to be sent to the Inbox of the annotation target (used by dokieli).</li>
                                    </ul>

                                    <p>Importantly, any existing <abbr title="Linked Data Platform">LDP</abbr> implementation can serve as an LDN receiver. Simply advertising any <code>ldp:Container</code> as the Inbox for a resource is sufficient. We confirmed this with three LDP servers which were developed prior to the LDN specification (Virtuoso, CarbonLDP and Solid Server).</p>

                                    <p>LDN has been integrated into existing domain specific systems: dokieli, IndieAnndroid, Linked Edit Rules, sloph, solid-client. Standalone implementations of LDN are also straightforward as a result of this modularity, ie: errol, mayktso, onscreen, pyLDN, RDF::LinkedData::Notifications, solid-inbox, solid-notifications.</p>
                                </div>
                            </section>

                            <section id="optimising-implementation" rel="schema:hasPart" resource="#optimising-implementation">
                                <h3 property="schema:name">Optimising implementation</h3>
                                <div datatype="rdf:HTML" property="schema:description">

                                    <p>The complexity of implementing a protocol can be considered in terms of the number of HTTP requests required for a core operation. In designing LDN, we have considered tradeoffs between the HTTP operations receivers and publishers are <em>required</em> to respond to, and ways in which developers may wish to optimise senders or consumers by reducing outbound requests.</p>

                                    <p><code>HEAD</code> requests are low cost, and <code>GET</code> requests may be high cost if the body of the resource is large. Given that an Inbox may be discovered from the HTTP headers of a resource, senders and consumers can optimise by attempting a <code>HEAD</code> request for discovery, and only continuing with a <code>GET</code> request if the <code>HEAD</code> is not successful.

                                    On the other hand, senders and consumers may be attempting discovery upon RDF resources which they already intend to parse into their own storage. In this case, there is no need for a HEAD request, as a GET will yield both HTTP Link Headers and an RDF body, either of which could include the Inbox triple.

                                    This means that resources advertising an Inbox must respond to <code>GET</code> requests (even if only with HTTP headers) and may respond to <code>HEAD</code> requests.</p>

                                    <!-- bother with OPTIONS for Accept-Post stuff, or no? Probably not worth space.. -->

                                    <p class="todo">Dependencies...</p>
                                </div>
                            </section>

                            <section id="precision" rel="schema:hasPart" resource="#precision">
                                <h3 property="schema:name">Precision</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>In treating notifications as any other Linked Data resources, LDN follows the 'fat ping' approach but without constraints on the contained information. LDN enables a sender to be precise and lossless with regards to the data it is transmitting. Approaches such as Webmention, which send only URLs, rely on the receiver interpreting a third-party resource, which may or may not contain structured markup, and may or may not be under the control of the sender. Semantic Pingback and Provenance Pingback offer additional guidance to aid the receiver in interpreting the source document(s), but as a result constrain the type of information that can be communicated.</p>

                                    <p>LDN therefore offers flexibility to senders, increasing the potential uses for the notification mechanism. LDN compensates for increased complexity on the receiver's end by recommending (but not requiring) possible filtering mechanisms, and moving some of the burden of 'sorting' or 'understanding' notifications to the consumer role. As such LDN can cover the uses cases of <q>A refers to B</q> (per the linkback approach), as well as <q>A has <em>x</em> relation to C, and <em>y</em> relation to D</q> (as qualified relation) and <q>The weather is fine today</q>.</p>
                                </div>
                            </section>

                            <section id="publishing-challenges" rel="schema:hasPart" resource="#publishing-challenges">
                                <h3 property="schema:name">Publishing challenges</h3>
                                <div datatype="rdf:HTML" property="schema:description">

                                    <p><strong>Inbox advertising</strong>: The relation between a resource and its Inbox could be argued to be either content-level data or purely protocol. Generally the separation of protocol and content is important, and content in RDF should describe itself rather relying on HTTP headers. Per <em>R4 Adaptability</em>, we wanted LDN to be available for all resources in any publishing context. Since binary formats such as images and video cannot contain an RDF relation, the HTTP Header is essential for including them. It also allows the inclusion of resources for which it is undesirable or impractical to add individual Inbox relations, such as to elements in a dataset; or circumstances where the developer responsible for the Inbox relation is unable to modify the content.</p>

                                    <p>Conversely, non-informational resources (represented with fragment URIs or 303 redirects) are unable to express HTTP headers. Their relation to an Inbox must be expressed in an RDF source.</p>

                                    <p>Thus, we require that senders and consumers must be equipped to discover Inboxes through both HTTP headers and RDF content. Given that a publisher of a target resource can outsource the receiver role to a third-party service, we consider prioritising a low barrier for publishers of target resources a worthwhile trade-off against slightly increased complexity for senders and consumers. One exception to this requirement is if a sender or consumer intends only ever to target non-informational resources; this is an acceptable domain-specific requirement, and in this case, they can exclude discovery via HTTP headers.</p>
                                    
                                    <p><strong>Target ownership</strong>: Publishers of target resources and their Inbox relations should do so on a server they trust. Publishers must be aware that third-party access to headers or content could result in notifications being redirected to somewhere they did not intend.</p>
                                </div>
                            </section>

                            <section id="content-challenges" rel="schema:hasPart" resource="#content-challenges">
                                <h3 property="schema:name">Content challenges</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p><strong>Natural Language Content</strong>: Building an international base of users is important in a federated network. Some LDN interactions can return content with natural language text, such as HTML fragments or plaintext literals. Providing multiple language representations of each item might not be feasible in all circumstances. Implementations are encouraged to provide means of discovering the available languages and/or negotiating the language returned, such as using the HTTP <code>Accept-Language</code> header, or the JSON-LD <code>@language</code> construct.</p>
                                    <p><strong>Modification of notifications</strong>: We have yet to assess the implications of applications modifying data that another application also makes use of. This would be a useful study for decentralisation in general.</p>
                                    <p><strong>Notifications as graphs</strong>:</p>
                                </div>
                            </section>

                        </div>
                    </section>

                    <section id="conclusions" inlist="" rel="schema:hasPart" resource="#conclusions">
                        <h2 property="schema:name">Conclusions</h2>
                        <div datatype="rdf:HTML" property="schema:description" resource="#conclusions" typeof="deo:Conclusion">
                            <p>In this article, ...</p>

                            <ul>
                                <li>This specification enables the notion of a notification as an individual entity with its own URI which can be retrieved and reused.</li>
                                <li>This specification deliberately does not define the vocabulary of the notification contents in order to allow for use in a range of different application domains.</li>
                                <li>Authentication and verification of notifications is encouraged, but the mechanism to do so is at the discretion of receivers and consumers, as needs differ according to types of notification and different application domains.</li>
                            </ul>

                            <p>We found a solution that is robust? efficient? working? flexible? accessible? evolvable?</p>
                            <p>The benefits are.. Prove?</p>
                            <p>Show some evidence that's reasonable.. to persuade the reader to reuse this work for further research.</p>

                            <p>Note: How about a discussion here?</p>

                            

                            

                            <p>Note: Future work?</p>
                        </div>
                    </section>

                    <section id="acknowledgements" inlist="" rel="schema:hasPart" resource="#acknowledgements">
                        <h2 about="#acknowledgements" property="schema:name" typeof="deo:Acknowledgements">Acknowledgements</h2>
                        <div datatype="rdf:HTML" property="schema:description">
                            <p>The motivation and work on notifications is inspired by ...</p>
                        </div>
                    </section>

                    <section id="references">
                        <h2>References</h2>
                        <div>
                            <ol>
                                <li id="">Fielding, R. T.: <cite>Architectural Styles and the Design of Network-based Software Architectures</cite>. Doctoral dissertation, University of California, Irvine, 2000, <a rel="schema:citation" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a></li>

                                <li id="">Klein, M., Van de Sompel, H., Warner, S., Klyne, G., Haslhofer, B., Nelson, M., Lagoze, C., Sanderson, R.: ResourceSync Framework Specification ‚Äì Change Notification, 2016, <a href="http://www.openarchives.org/rs/notification/1.0/notification">http://www.openarchives.org/rs/notification/1.0/notification</a></li>
                            </ol>
                        </div>
                    </section>
                </div>
            </article>
        </main>
    </body>
</html>
